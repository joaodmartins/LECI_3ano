#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <memory.h>
#include <unistd.h>
#include <fcntl.h>
#include <time.h>
#include <assert.h>

// gcc -O2 -Wall avalanche-analysis.c -o avalanche-analysis -lcrypto

#include <openssl/types.h>
#include <openssl/evp.h>
#include <openssl/md5.h>
#include <openssl/sha.h>

#ifndef MAX
#define MAX(x,y) (x > y ? x : y)
#endif

// this is big enough for all our targets: sha256 and md5
#define HASH_OUTPUT_MAX_BYTES   MAX( MD5_DIGEST_LENGTH,SHA256_DIGEST_LENGTH )
#define HASH_OUTPUT_MAX_BITS	(8 * HASH_OUTPUT_MAX_BYTES)
#define HASH_OUTPUT_BLOCK_SIZE	HASH_OUTPUT_MAX_BYTES

/*
 * TODO
 * you may want to give more options and details here!
*/
int bad_usage( const char *p ) {
    fprintf(stderr, "Usage:\n\t%s  M  N\n\n"
                    "\tM: the size in bytes of the initial source message\n"
                    "\tN: the number of one-bit altered messages\n"
                    "\n",p);
    return -2;
}

static int ones[16] = {
    0, 1, 1, 2, // 0 to 3
    1, 2, 2, 3, // 4 to 7
    1, 2, 2, 3, // 8 to 11
    2, 3, 3, 4  // 12 to 15
};

/*
 * Counts 1's in a byte
*/
int
count_1s( uint8_t c )
{
    return ones[c & 0xF] + ones[c >> 4];
}

/*
 * Returns the number of bits at 1 within the first `size` bytes
*/
int
count_diff_bits( const uint8_t *h1, const uint8_t *h2, const uint32_t size )
{
    int n = 0;

    for (int i = 0; i < size; i++) {
        n += count_1s( h1[i] ^ h2[i] );
    }

    assert(n <= 8 * size);

    return n;
}

/*
 * Copies `source` to `working_buf` and changes a bit on `working_buf`
 * also writes the index of the bit changed to `track_mods`
*/
void change_me_a_bit( const uint8_t *source, const uint32_t source_size,
		      uint8_t *track_mods, uint8_t *working_buf)
{
    memcpy( working_buf, source, source_size );

    uint32_t bit_idx = rand() % source_size * 8; // the (random) bit index
    uint32_t byte_idx = bit_idx / 8;
    uint32_t bit_offset = bit_idx % 8;
    uint8_t bit_mask = 1 << bit_idx;

    uint32_t try = 0;

    while (track_mods[byte_idx] & bit_mask) { // Deja vu bit?
	try++;

        assert( try < source_size * 8); // if all bits were already modified

	bit_idx = (bit_idx + 1) % (source_size * 8); // Try next bit
	byte_idx = bit_idx / 8;
	bit_offset = bit_idx % 8;
	bit_mask = 1 << bit_idx;
    }

    working_buf[byte_idx] ^= bit_mask; // change the bit
    track_mods[byte_idx] |= bit_mask; // stores the action

    assert( count_diff_bits( source, working_buf, source_size ) == 1);
}

/*
 * TODO
 * Similar to change_me_a_bit but a byte!
*/
void change_me_a_byte( const uint8_t *source, const uint32_t source_size,
                       uint8_t *track_mods, uint8_t *working_buf )
{
    memcpy( working_buf, source, source_size );


}

/* 
 * Produces sha256 from `data` with `data_size` bytes and writes the output to `output_hash`
*/
void
sha256( const uint8_t *data, const uint32_t data_size, uint8_t *output_hash )
{
    EVP_MD_CTX * ctx = EVP_MD_CTX_new(); // The generic hashing context

    EVP_DigestInit( ctx, EVP_sha256() ); // Context initialization

    // Process the entire data and Compute the the final hash value
    EVP_DigestUpdate( ctx, data, data_size );
    EVP_DigestFinal( ctx, output_hash, 0 );

    EVP_MD_CTX_free( ctx );
}

/* 
 * TODO 
 * Produces md5 from `data` with `data_size` bytes and writes the output to `output_hash`
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <memory.h>
#include <unistd.h>
#include <fcntl.h>
#include <time.h>
#include <assert.h>

// gcc -O2 -Wall avalanche-analysis.c -o avalanche-analysis -lcrypto

#include <openssl/types.h>
#include <openssl/evp.h>
#include <openssl/md5.h>
#include <openssl/sha.h>

#ifndef MAX
#define MAX(x,y) (x > y ? x : y)
#endif

// this is big enough for all our targets: sha256 and md5
#define HASH_OUTPUT_MAX_BYTES   MAX( MD5_DIGEST_LENGTH,SHA256_DIGEST_LENGTH )
#define HASH_OUTPUT_MAX_BITS	(8 * HASH_OUTPUT_MAX_BYTES)
#define HASH_OUTPUT_BLOCK_SIZE	HASH_OUTPUT_MAX_BYTES

/*
 * TODO
 * you may want to give more options and details here!
*/
int bad_usage( const char *p ) {
    fprintf(stderr, "Usage:\n\t%s  M  N\n\n"
                    "\tM: the size in bytes of the initial source message\n"
                    "\tN: the number of one-bit altered messages\n"
                    "\n",p);
    return -2;
}

static int ones[16] = {
    0, 1, 1, 2, // 0 to 3
    1, 2, 2, 3, // 4 to 7
    1, 2, 2, 3, // 8 to 11
    2, 3, 3, 4  // 12 to 15
};

/*
 * Counts 1's in a byte
*/
int
count_1s( uint8_t c )
{
    return ones[c & 0xF] + ones[c >> 4];
}

/*
 * Returns the number of bits at 1 within the first `size` bytes
*/
int
count_diff_bits( const uint8_t *h1, const uint8_t *h2, const uint32_t size )
{
    int n = 0;

    for (int i = 0; i < size; i++) {
        n += count_1s( h1[i] ^ h2[i] );
    }

    assert(n <= 8 * size);

    return n;
}

/*
 * Copies `source` to `working_buf` and changes a bit on `working_buf`
 * also writes the index of the bit changed to `track_mods`
*/
void change_me_a_bit( const uint8_t *source, const uint32_t source_size,
		      uint8_t *track_mods, uint8_t *working_buf)
{
    memcpy( working_buf, source, source_size );

    uint32_t bit_idx = rand() % source_size * 8; // the (random) bit index
    uint32_t byte_idx = bit_idx / 8;
    uint32_t bit_offset = bit_idx % 8;
    uint8_t bit_mask = 1 << bit_idx;

    uint32_t try = 0;

    while (track_mods[byte_idx] & bit_mask) { // Deja vu bit?
	try++;

        assert( try < source_size * 8); // if all bits were already modified

	bit_idx = (bit_idx + 1) % (source_size * 8); // Try next bit
	byte_idx = bit_idx / 8;
	bit_offset = bit_idx % 8;
	bit_mask = 1 << bit_idx;
    }

    working_buf[byte_idx] ^= bit_mask; // change the bit
    track_mods[byte_idx] |= bit_mask; // stores the action

    assert( count_diff_bits( source, working_buf, source_size ) == 1);
}

/*
 * TODO
 * Similar to change_me_a_bit but a byte!
*/
void change_me_a_byte( const uint8_t *source, const uint32_t source_size,
                       uint8_t *track_mods, uint8_t *working_buf )
{
    assert( 1 == 0 );
}

/* 
 * Produces sha256 from `data` with `data_size` bytes and writes the output to `output_hash`
*/
void
sha256( const uint8_t *data, const uint32_t data_size, uint8_t *output_hash )
{
    EVP_MD_CTX * ctx = EVP_MD_CTX_new(); // The generic hashing context

    EVP_DigestInit( ctx, EVP_sha256() ); // Context initialization

    // Process the entire data and Compute the the final hash value
    EVP_DigestUpdate( ctx, data, data_size );
    EVP_DigestFinal( ctx, output_hash, 0 );

    EVP_MD_CTX_free( ctx );
}

/* 
 * TODO 
 * Produces md5 from `data` with `data_size` bytes and writes the output to `output_hash`
*/
void
md5( const uint8_t *data, const uint32_t data_size, uint8_t *output_hash )
{
    assert( 1 == 0);
}


int
main( int argc, char *argv[] )
{
    // we want 2 arguments
    if (argc != 3) {
        return bad_usage( argv[0] );
    }

    // get the numbers
    const uint32_t source_size;
    const uint32_t n_variations;

    assert( sscanf( argv[1], "%d", &source_size ) );
    assert( sscanf( argv[2], "%d", &n_variations ) );

    fprintf(stderr,"Working with M=%d and N=%d...\n",source_size,n_variations);

    assert( n_variations <= source_size * 8 );

    // get some space for histogram and fill it with zeros
    uint32_t histogram[HASH_OUTPUT_MAX_BITS + 1];
    memset( histogram, 0,sizeof(histogram) );

    // space for source
    uint8_t * source = malloc( source_size );
    assert( source != 0 );

    // space for 1bit variation
    uint8_t * bit_mod = malloc( source_size );
    assert( bit_mod != 0 );

    /*
     * Used to avoid repetition on the 1bit modification...
     * calloc zeros it
    */
    uint8_t * track_mods = calloc( source_size, 1 );

    // Fill source with random data fickedup from /dev/urandom file
    int fd = open( "/dev/urandom", 0 );
    read( fd, source, source_size );
    close ( fd );

    uint8_t source_hash[HASH_OUTPUT_BLOCK_SIZE];
    uint8_t bit_mod_hash[HASH_OUTPUT_BLOCK_SIZE];

    const int size_of_hash = SHA256_DIGEST_LENGTH;

    sha256( source, source_size, source_hash );

    /*
     *  TODO
     *  Probably you will start from here...
     *  without any modification it will just work for N = 1
    */

    change_me_a_bit( source, source_size, track_mods, bit_mod );
    sha256( bit_mod, source_size, bit_mod_hash );

    const int n = count_diff_bits( source_hash, bit_mod_hash, size_of_hash );

    histogram[n]++;

    // make sure we have used N different 1bit modifications
    uint8_t * zeros = calloc( source_size, 1 );
    assert(count_diff_bits( bit_mod, zeros, source_size ) == n_variations);

    printf("The results are...\n");
    for (int i = 0;i <= size_of_hash * 8; i++) {
        printf("[%3d] = %d\n", i, histogram[i]);
    }

    /*
     *
     *  probably there is nothing to do bellow...
     *
    */
    free(source);
    free(bit_mod);
    free(track_mods);

    return 0;
}*/
void
md5( const uint8_t *data, const uint32_t data_size, uint8_t *output_hash )
{
    assert( 1 == 0);
}


int
main( int argc, char *argv[] )
{
    // we want 2 arguments
    if (argc != 3) {
        return bad_usage( argv[0] );
    }

    // get the numbers
    const uint32_t source_size;
    const uint32_t n_variations;

    assert( sscanf( argv[1], "%d", &source_size ) );
    assert( sscanf( argv[2], "%d", &n_variations ) );

    fprintf(stderr,"Working with M=%d and N=%d...\n",source_size,n_variations);

    assert( n_variations <= source_size * 8 );

    // get some space for histogram and fill it with zeros
    uint32_t histogram[HASH_OUTPUT_MAX_BITS + 1];
    memset( histogram, 0,sizeof(histogram) );

    // space for source
    uint8_t * source = malloc( source_size );
    assert( source != 0 );

    // space for 1bit variation
    uint8_t * bit_mod = malloc( source_size );
    assert( bit_mod != 0 );

    /*
     * Used to avoid repetition on the 1bit modification...
     * calloc zeros it
    */
    uint8_t * track_mods = calloc( source_size, 1 );

    // Fill source with random data fickedup from /dev/urandom file
    int fd = open( "/dev/urandom", 0 );
    read( fd, source, source_size );
    close ( fd );

    uint8_t source_hash[HASH_OUTPUT_BLOCK_SIZE];
    uint8_t bit_mod_hash[HASH_OUTPUT_BLOCK_SIZE];

    const int size_of_hash = SHA256_DIGEST_LENGTH;

    sha256( source, source_size, source_hash );

    /*
     *  TODO
     *  Probably you will start from here...
     *  without any modification it will just work for N = 1
    */

    change_me_a_bit( source, source_size, track_mods, bit_mod );
    sha256( bit_mod, source_size, bit_mod_hash );

    const int n = count_diff_bits( source_hash, bit_mod_hash, size_of_hash );

    histogram[n]++;

    // make sure we have used N different 1bit modifications
    uint8_t * zeros = calloc( source_size, 1 );
    assert(count_diff_bits( bit_mod, zeros, source_size ) == n_variations);

    printf("The results are...\n");
    for (int i = 0;i <= size_of_hash * 8; i++) {
        printf("[%3d] = %d\n", i, histogram[i]);
    }

    /*
     *
     *  probably there is nothing to do bellow...
     *
    */
    free(source);
    f
